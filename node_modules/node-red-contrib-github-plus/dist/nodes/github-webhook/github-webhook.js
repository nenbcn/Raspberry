"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const body_parser_1 = __importDefault(require("body-parser"));
const crypto_1 = require("crypto");
const config_1 = require("./modules/config");
const statuses = {
    misconfigured: {
        fill: "red",
        shape: "ring",
        text: "misconfigured",
    },
    error: { fill: "red", shape: "dot", text: "error" },
    listening: {
        fill: "green",
        shape: "dot",
        text: "listening",
    },
    blank: {},
};
const nodeInit = (RED) => {
    function GithubWebhookNodeConstructor(config) {
        RED.nodes.createNode(this, config);
        if (RED.settings.httpNodeRoot === false) {
            this.error("Cannot create github-webhook node when httpNodeRoot set to false");
            this.status(statuses.misconfigured);
            return;
        }
        if (!config.path) {
            this.status(statuses.misconfigured);
            return;
        }
        let path = config.path;
        if (path[0] !== "/") {
            path = "/" + path;
        }
        // NodeRED uses bodyParser.json on httpAdminRoot, and this makes it impossible to get raw body on all child paths
        if (RED.settings.httpAdminRoot === "/") {
            this.error("Cannot create github-webhook node when httpAdminRoot set to '/'");
            this.status(statuses.misconfigured);
            return;
        }
        if (typeof RED.settings.httpAdminRoot === "string" &&
            path.startsWith(RED.settings.httpAdminRoot)) {
            this.error(`Cannot create github-webhook node on child routes of httpAdminRoot (${RED.settings.httpAdminRoot})`);
            this.status(statuses.misconfigured);
            return;
        }
        if (!this.credentials.secret) {
            this.status(statuses.misconfigured);
            return;
        }
        const secret = this.credentials.secret;
        const postHandler = (req, res, _next) => {
            const evtName = req.headers["x-github-event"];
            const guid = req.headers["x-github-delivery"];
            const msg = {
                _msgid: RED.util.generateId(),
                guid,
                topic: evtName,
                payload: req.body,
            };
            this.send(msg);
            res.status(200).send("ok");
            // status = time of the last notification
            this.status({
                ...statuses.listening,
                text: new Date().toISOString(),
            });
        };
        const errorHandler = (err, _req, res, _next) => {
            this.error(err);
            res.sendStatus(err.status || 500);
            this.status(statuses.error);
        };
        const jsonParser = body_parser_1.default.json({
            // Payloads are capped at 25 MB
            // Source: https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/webhook-events-and-payloads#webhook-payload-object-common-properties
            limit: "25mb",
            // Get Raw Body
            verify: (req, _res, buf, _encoding) => {
                const noHeaders = [
                    "x-github-delivery",
                    "x-github-event",
                    "x-hub-signature-256",
                ].filter((header) => !(header in req.headers));
                if (noHeaders.length > 0) {
                    throw new Error("invalid incoming data (missing headers): " + noHeaders.join(", "));
                }
                const sig = req.headers["x-hub-signature-256"];
                const bufSig1 = Buffer.from(sig);
                const bufSig2 = Buffer.from("sha256=" + crypto_1.createHmac("sha256", secret).update(buf).digest("hex"));
                if (bufSig1.length !== bufSig2.length ||
                    !crypto_1.timingSafeEqual(bufSig1, bufSig2)) {
                    throw new Error("Invalid incoming data (signature mismatch)");
                }
            },
        });
        this.status({
            ...statuses.listening,
            text: "no notifications yet",
        });
        // add listener
        RED.httpNode.post(path, jsonParser, postHandler, errorHandler);
        this.on("close", () => {
            // remove listener(s)
            RED.httpNode._router.stack.forEach((route, i, routes) => {
                if (route.route &&
                    route.route.path === path &&
                    route.route.methods.post) {
                    routes.splice(i, 1);
                }
            });
        });
    }
    RED.nodes.registerType("github-webhook", GithubWebhookNodeConstructor, {
        credentials: config_1.githubWebhookCredentials,
    });
};
module.exports = nodeInit;
//# sourceMappingURL=github-webhook.js.map